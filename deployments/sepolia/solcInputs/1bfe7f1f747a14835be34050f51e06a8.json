{
  "language": "Solidity",
  "sources": {
    "contracts/FHEStake.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/// @title Simple ETH Staking with Rewards (Sepolia)\n/// @notice Users can stake native ETH, earn ETH rewards over time, and withdraw\ncontract FHEStake {\n    uint256 public rewardRate; // wei rewarded per second per wei staked\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public balances;\n\n    uint256 private _totalSupply;\n    address public owner;\n\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardRateChanged(uint256 newRate);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = block.timestamp;\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    constructor(uint256 _rewardRate) {\n        owner = msg.sender;\n        rewardRate = _rewardRate;\n        lastUpdateTime = block.timestamp;\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return rewardPerTokenStored + ((block.timestamp - lastUpdateTime) * rewardRate * 1e18) / _totalSupply;\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return (balances[account] * (rewardPerToken() - userRewardPerTokenPaid[account])) / 1e18 + rewards[account];\n    }\n\n    /// @notice Stake native ETH\n    function stake() external payable updateReward(msg.sender) {\n        require(msg.value > 0, \"Cannot stake 0\");\n        _totalSupply += msg.value;\n        balances[msg.sender] += msg.value;\n        emit Staked(msg.sender, msg.value);\n    }\n\n    /// @notice Withdraw staked ETH\n    function withdraw(uint256 amount) public updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        require(balances[msg.sender] >= amount, \"Not enough staked\");\n        _totalSupply -= amount;\n        balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    /// @notice Claim ETH rewards\n    function claimReward() public updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            payable(msg.sender).transfer(reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    /// @notice Withdraw stake + claim rewards\n    function exit() external {\n        withdraw(balances[msg.sender]);\n        claimReward();\n    }\n\n    /// @notice Owner can change reward rate\n    function setRewardRate(uint256 _rate) external onlyOwner updateReward(address(0)) {\n        rewardRate = _rate;\n        emit RewardRateChanged(_rate);\n    }\n\n    /// @notice Contract can receive ETH (to fund rewards)\n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "evmVersion": "cancun",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}